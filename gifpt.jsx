//#region Logo Binary
var main_logo_binary = "\x89\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\x00\x01\x5f\x00\x00\x00\x64\x08\x06\x00\x00\x00\x21\x7f\x33\x5b\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0b\x12\x00\x00\x0b\x12\x01\xd2\xdd\x7e\xfc\x00\x00\x0a\xb7\x49\x44\x41\x54\x78\x9c\xed\x9d\xfd\x6d\xe3\x38\x13\x87\xb5\x2f\xde\x06\x7c\x25\x24\x25\x38\x25\x78\x4b\xc8\x96\x60\x77\xa0\x44\x80\xfe\x34\xe0\xd8\x1d\x24\x25\xac\x4b\x88\x4b\x88\x4b\x38\xb7\xe0\x12\x72\x60\x6e\x94\xa3\xb4\xfc\xd2\x27\x25\xeb\x79\x00\x01\xbb\x89\xad\x88\x14\xf5\xd3\x70\x66\x38\xfc\xf1\xf9\xf9\x99\x00\x00\xc0\xb0\xfc\x8f\xfe\x06\x00\x18\x1e\xc4\x17\x00\x20\x02\x88\x2f\x00\x40\x04\x10\x5f\x00\x80\x08\x20\xbe\x00\x00\x11\x40\x7c\x01\x00\x22\x80\xf8\x02\x00\x44\x00\xf1\x05\x00\x88\x00\xe2\x0b\x00\x10\x01\xc4\x17\x00\x20\x02\x88\x2f\x00\x40\x04\x10\x5f\x00\x80\x08\x20\xbe\x00\x00\x11\x40\x7c\x01\x00\x22\x80\xf8\x02\x00\x44\x00\xf1\x05\x00\x88\x00\xe2\x0b\x00\x10\x01\xc4\x17\x00\x20\x02\x88\x2f\x00\x40\x04\x10\x5f\x00\x80\x08\x20\xbe\x00\x00\x11\xf8\x3f\x9d\x3e\x1d\xd2\x2c\x5f\x24\x49\xb2\x4e\x92\xe4\x31\x49\x92\x65\x92\x24\xd7\x24\x49\x8e\x49\x92\xec\x0f\xbb\xed\xa5\x4d\x43\xd2\x2c\x2f\xce\x59\x1c\x0b\xed\xd7\xa7\x24\x49\xce\xea\x6f\x1d\x76\xdb\xf3\x4c\xba\x1b\xa0\x57\xd8\x3a\x7e\x22\x88\xf0\xbe\x8b\x30\x9a\xd8\x1c\x76\xdb\xb7\xba\xad\x49\xb3\x5c\x89\xf9\x53\x92\x24\x77\x81\x5f\x51\x42\xfc\x8c\x08\x03\xb4\x03\xcb\x77\x3a\xfc\x76\x08\xaf\xe2\x35\xcd\xf2\x53\xa8\x05\x2c\x62\xae\xce\xb9\xaa\xd9\x03\x2b\x79\x09\xfc\x75\x03\x7d\x0a\x16\xd2\x2c\x5f\xc9\xbd\x36\xcd\x84\xae\x32\x13\x52\x87\x1a\x73\x27\xfa\xb1\x3e\x88\xef\x04\x48\xb3\xfc\x2e\x50\x24\x95\x05\xbb\xf1\x7d\x28\xc0\x8a\x86\x01\xd1\xdc\x49\x4f\x9a\xc8\x9d\x0f\xbb\xed\x43\xa4\xeb\x58\x7b\x66\x42\x0b\x19\x8f\xea\x78\x4a\xb3\x5c\xbd\xf0\xd5\xac\xeb\xed\xb0\xdb\x5e\x07\xbc\xe4\x49\x43\xc0\x6d\x1a\x3c\x06\x5e\x65\xe8\xe7\x5e\x5b\x0a\x2f\x2e\x87\x8e\x10\x5f\xfb\x47\x92\x24\x2f\x15\xeb\x72\xd0\x17\xa3\x58\xba\xc5\x75\x84\xba\xa0\x0a\xee\xe4\x7b\x1f\x72\x1e\x08\x00\xf1\xbd\x2d\x16\xbe\xd6\xc8\xc3\x11\x2a\xd2\x36\x98\x66\xb6\x44\xcd\x66\xd2\x2c\x7f\x17\xd7\x4f\x5d\xb1\xeb\xfa\x5a\xd6\x32\x13\x6a\x7b\x1d\xea\xfb\xef\x72\x3e\xf0\x80\xf8\x4e\x83\xd0\xa9\x5c\x88\x45\xfa\xd4\x41\x8b\x99\x5a\x36\x44\x4d\xed\xd3\x2c\x57\xf7\xe0\xef\x06\xfe\xf6\x3e\xae\x67\x2d\x33\xa1\x2e\x79\x45\x80\xfd\xe0\xf3\x9d\x06\x47\xc3\xb4\xd4\xc4\xd1\xf5\xcb\x1a\xbe\x63\x1f\xad\xd2\xda\xfa\x46\xda\xe9\xb2\xe2\xce\x31\x7c\x93\x22\x48\x21\xf7\x71\x10\xc4\xe5\xe1\x12\xde\x93\x8c\xa9\x52\x20\x57\x1b\x47\x8f\x8e\xf1\xa4\x04\xf8\x7a\xd8\x6d\x9d\x63\x72\xce\x20\xbe\x13\x40\x09\x45\x9a\xe5\xcf\x9e\x07\xe5\x2c\x41\x0f\x17\xa1\xee\x86\xb3\xe4\x0e\x7f\x3d\x38\x12\x88\xf9\x7e\xd8\x26\x10\xdd\xf6\x4d\xa1\x95\x90\xdc\x0f\x75\x31\x69\x96\x2f\x45\x74\x47\xe3\x0f\x15\x01\xb5\x8d\x27\xf5\x62\xfa\x65\xbb\xcf\x22\xc4\x5f\x01\x36\x71\x63\xfd\xb6\xbc\x50\x94\x00\x9f\xdb\xe6\xa0\xdf\x2a\x88\xef\x44\x50\x39\xbc\x69\x96\x27\x16\xcb\xe9\x24\x0f\x8b\xcf\x9a\x0b\x09\xe2\xa8\x07\xe5\xa7\x7e\x2e\xf9\xf7\xd1\x67\x59\x8f\x08\x9f\xef\x72\x68\x1f\xeb\xfb\x58\xac\x5d\x0d\x9b\x05\x7e\xae\xde\x7f\x17\x4a\xa0\xd3\x2c\xbf\xb7\x64\xcf\x2c\xe4\xef\xfc\x1a\xa0\x3d\x93\x03\x9f\xef\x84\x90\x45\x14\xf7\x92\x4e\xf6\x2c\xc7\xfd\x61\xb7\x0d\x7d\x58\x42\x04\x80\x74\xa1\xee\xb1\xf5\xfb\x51\xbb\x97\x83\xe1\x08\xba\x5e\x03\x5f\xe2\x25\xe4\xf3\x3f\x2d\xb1\x80\x47\x32\x20\xcc\x60\xf9\x4e\x0c\x19\xe8\xb5\x57\xb2\x09\x21\x0f\x01\x99\x0c\xfd\x72\x16\xd1\xfd\x7e\xc9\x49\x00\x6e\x48\x6c\xee\xa7\x4d\x53\x17\x81\xb8\xc6\x36\xe2\x82\xa8\xf2\xc8\xb8\xfa\x13\xc4\x17\x4a\xb0\x6c\xb8\x17\xf6\x45\x1d\x8e\xd8\xfe\x4f\x6d\x21\x45\x95\x53\xdb\xe0\x98\xfa\xbe\x5a\x65\x69\x78\xc9\xaf\x55\xcc\x82\x19\x55\x19\xc4\x17\xa0\x67\x0e\xbb\xed\xa0\x6e\x05\x0f\xb6\x14\xb0\xa6\xb3\x29\xd3\x79\x4c\x33\xac\xb5\xbc\x84\x40\x40\x7c\x6b\x22\x91\xeb\x47\xc3\x9a\xf7\x8b\x1c\x67\x49\x65\xb2\x5a\x11\x62\x7d\x54\x83\x13\xce\xf4\x27\x49\x0b\x72\x06\x8a\x0e\xbb\x6d\x69\x70\xcb\xb5\xd6\x0a\xf4\x04\xf8\xe7\x4a\xd7\xd9\xa2\x2d\x45\xff\xe9\x69\x61\x7a\xcd\x80\x5a\x15\xd4\x2c\xd7\xe1\xfa\x7c\xad\x76\xde\x10\xa6\x76\x5f\xba\x4a\x09\x13\xeb\xf7\x62\x18\xab\x2b\xc4\xb7\x0c\xe2\x1b\x88\x3c\xac\x4f\x0e\xbf\x69\x21\x22\x5f\xbf\x57\x39\x8e\x32\xd8\x4c\x01\x2c\x53\x64\xd8\x97\xfe\xf4\xea\x13\x52\x29\xac\x73\x4e\xda\x25\xcf\xbf\x7b\x7e\xaf\x7c\x7b\xf7\x5a\x9b\x3e\x0c\x0f\x9a\xba\x86\x52\x5d\x02\x4b\xfd\x82\x2a\xd5\x9a\x01\x27\x49\x79\x0b\xf1\x17\x9a\xae\xc3\x45\xdd\x76\xde\x0a\xa6\xf1\xdb\xb5\x3f\xf6\x68\x58\xcc\x43\xd0\xad\x02\xd9\x0e\x1e\x64\x45\xd2\x8b\x3c\xac\x75\x06\xd0\xc2\xb4\xde\x5d\x82\x2b\x26\x0b\xcd\x27\x1c\x21\x16\xec\xc2\xf2\xef\x2e\xa9\x5a\x98\xa6\xeb\x5e\xea\x41\xa4\x4a\xdd\x80\x3a\xd7\xb5\x92\xe5\xaa\x2f\x22\xde\x2e\xba\x4e\x1f\xab\x65\x49\x4f\x01\x87\xb5\xdf\xb5\xf8\x1a\x67\x2c\x64\x3d\x94\xc1\xf2\x75\xd0\x51\xf5\xaf\x62\xbd\xfb\xc6\x62\x11\xdc\x2a\xca\x72\x7d\x13\x17\x4d\xdb\xe5\xab\x5f\x33\x8e\x34\xcb\x83\xf3\x4f\xc1\x88\x6d\x1c\x77\x2d\xbe\xb6\xf3\x2d\xc9\x7a\xf8\x0f\x2c\x5f\x0b\x3d\x94\x5d\x7c\x15\xeb\x6f\x6c\xc9\xf6\x7d\xb1\x90\xf6\x76\x55\x37\x60\x29\x2f\xb1\xb9\xf4\x5f\x1f\x98\xfa\xee\xda\xf5\x0b\x4d\xce\x67\x3a\x27\xf7\x4e\x03\xf1\xb5\xf3\xd2\xc3\xb4\x33\x6a\xf5\xaa\x08\x74\xdd\xde\x62\x99\x2e\x34\xef\xbf\x2a\x7d\xa5\x16\x9a\xce\x4b\xfd\x68\x0d\xc4\xd7\x80\x44\xe3\xa9\xca\x34\x4e\xd6\x72\x7f\xa0\x1b\xfa\x72\xe3\xe0\x1e\xf2\x80\xf8\x9a\xb9\x05\xeb\xea\xdc\xd3\x03\x30\x86\x6d\x63\x4c\xf7\xa7\xeb\xba\x13\xb7\xb8\x3d\x0e\x96\xef\x88\x20\xe0\x56\x41\x52\xb4\x42\xa7\xcb\x45\x3a\xd9\xf7\xca\x25\x2d\x0f\x38\x6a\x60\x4d\x84\xa3\xb4\xcf\x5a\x9a\xe5\xde\xdd\x52\x0f\xbb\xed\x8f\x5e\x2f\xec\x5f\xf6\x7a\x1e\xaf\x54\xd8\x7a\xf4\xa4\xa1\xe9\xa8\x42\xe4\x6b\x7d\xc3\xd0\xc3\x6e\xfb\x5d\xbc\x65\x44\xed\x1c\x1b\xb1\x7d\xae\xf8\x7c\x35\x10\xdf\x3f\x09\x75\x37\x18\xab\x3f\x89\xa0\x9c\xd3\x2c\x3f\x8e\x61\x97\x82\x91\x71\x91\xc2\x2d\x25\xab\x48\x5e\x5c\x7b\xc9\x8e\x08\x0d\x72\xae\x3b\x5c\x95\x05\x30\x38\xb8\x1d\x34\xc4\x02\x0b\x79\xf0\xbd\x65\xf7\x44\x60\x1e\xf0\x7d\x7d\xa3\xfa\xe1\xc1\xb5\x6a\x4d\xab\x8e\x15\x32\x15\x5e\xca\xfd\x02\x98\x24\x88\x6f\x99\xd0\x40\xce\x26\x24\x3d\x47\x3e\x33\xa6\x75\xfd\x31\x09\x2a\xac\x22\x9f\xf1\xee\xc0\x2c\x10\x78\x83\xc9\x82\xf8\x96\x09\xb1\xa4\xde\xea\xd4\x1c\x10\xbf\xe4\xdc\x2b\xf9\x5f\x74\xff\xac\x0f\xe9\xdf\x90\x00\x1a\x96\x6f\x3d\x62\xcf\xc2\x98\x05\x6a\x20\xbe\x65\x42\x1e\xe6\x26\xd1\xe1\xb9\xfb\x26\x9b\xb4\x3f\x24\xd3\x00\xf1\xad\xc7\x90\x19\x08\x43\x66\x56\x4c\x12\xc4\xb7\x4c\xc8\xda\xf3\x26\x29\x4d\x73\x1f\x74\x4d\xda\x1f\x22\xbe\xd4\x0a\x68\x4f\x9f\x35\x40\xc0\x01\xe2\x5b\x13\x6a\x0b\x0c\x03\x9b\x2e\xf6\x02\x96\xef\x88\x40\x7c\x01\xe6\x83\xb1\xde\x42\xd7\xf5\x32\xe4\x7c\xc6\x3a\x12\x8c\xb5\xff\x40\x7c\x6b\x42\x61\x97\x61\xa0\x9f\x7b\xc1\x66\x79\x76\xed\xbe\xb1\x9d\x0f\xcb\x57\x03\xf1\x2d\x13\xe2\x67\x6c\x92\xde\x34\xf7\x65\x95\x4d\xda\x1f\xd2\xcf\x94\x27\xac\x81\x63\xb9\x74\xd7\xe3\xd3\x78\xbe\x1b\x5c\xae\xdd\x0a\xc4\xb7\x4c\xc8\xb4\xa8\xc9\x40\x9d\x7b\x91\x9e\x26\xed\x0f\xe9\x67\xa6\xb1\xf5\x31\x09\x60\xd7\xf9\xd2\xa6\xf3\x21\xbc\x15\x10\xdf\x32\x21\xd3\xa2\xb5\xd4\x6f\x08\xa2\x66\xad\x88\x5b\xe5\x4e\xfa\x21\xb4\xcf\x96\x81\x82\xdd\x78\x1a\x3b\xe3\x5d\x15\x4c\x22\x78\xd7\x55\xa5\x38\xc7\x5e\x83\x88\x6f\x05\xc4\xb7\x4c\xe8\x00\x79\x0d\xf1\x49\xca\xf2\x57\xea\xcf\xfe\x4b\xc8\x56\x40\x85\xaf\x37\xb4\x00\xbb\xed\x7e\x85\xdc\xc7\xb9\xba\x82\x6c\xa9\x92\x5d\xcd\xce\xfa\xde\x1d\xf9\x66\x40\x7c\x35\x64\x65\x55\x48\x8a\x53\xb1\xab\x82\xd5\xa2\x15\xeb\x6d\x4e\x3b\x57\xf8\x50\xfd\xf0\xb7\x6b\xd6\x20\xfd\x19\x5a\x58\xe7\xe2\x58\x69\x18\xe2\x8e\x78\x9a\x63\x50\x4f\x52\xf8\x4c\x42\xb8\x6a\x6b\xfd\xca\xf7\x4d\x33\x0a\xd3\x26\xb2\xb3\x87\xaa\x66\x7f\xf2\x16\x68\xad\x2e\x65\x73\xcc\x37\xbd\xf6\xab\x36\x00\xe7\xee\xe7\x35\xb1\xa8\xf4\xd9\x97\x15\x26\x2e\x80\xa2\xcf\x42\x05\xd1\x65\x49\x9d\x03\xfc\x98\xc5\xb5\x14\xe5\x2d\xaf\xf2\x62\x28\x5c\x1e\x77\x87\xdd\xf6\x2f\xcf\x39\xa6\xca\xd1\x32\x3e\xd5\x8c\xee\xdc\x24\xc7\xda\x33\x63\xe9\xba\xd6\xf2\x4d\x80\xf8\xfe\xc9\x5b\x8d\xba\xb2\x0b\xf9\xac\xb2\xa2\x86\xbe\xce\x29\xb3\x16\xdf\x79\xd3\x26\x5c\x3d\xe2\x7b\x0c\x7c\x81\xde\x89\x60\xbc\x9a\xae\x45\xbd\x14\xa6\x10\xa1\x17\x7f\x7a\x61\x71\x2a\xf1\xdc\xbb\x3e\xaf\xda\x24\x25\x4f\xab\x2f\x28\x35\x9e\x7f\xd7\xdd\xa8\x54\xdb\xef\xd0\xf4\xcc\x1c\xc9\x72\x30\x83\xdb\xa1\x82\x0c\x3a\xe7\xe0\x85\xe8\xec\x3d\xe5\x3c\x2f\x1d\x05\x78\x46\x1f\x28\x4d\xb3\xfc\x55\x5e\x20\x8f\x72\x28\xdf\xfa\x47\x80\x4b\xe5\xd9\xe2\x9e\x59\x8a\x7b\x28\x28\x20\x29\x9f\xfb\xb0\xb8\x8a\xa8\xea\xe7\x00\xcb\xd7\x80\xb2\x1c\xb4\x1d\x29\x60\x5c\x1c\x7d\x96\x9d\xb0\xef\x60\xf1\xc0\xa8\xc5\x57\x2c\x5e\x93\xfb\xa0\xd8\x68\xd4\x5a\x9a\x53\xbd\xa0\xd2\x2c\xdf\x48\xc1\xff\x2a\x0b\x89\x69\x9c\x64\x16\x71\xd2\x5d\x11\xe2\x9b\x5f\xc9\xf3\xe1\xea\xe3\x0d\xcb\xc4\xed\x60\xf9\xda\xd9\xb0\x22\x67\x74\x9c\x43\x6b\xfd\xca\x54\xb7\xed\x0c\x66\xec\x19\x11\x2e\xe1\xf3\x1a\x0e\xe2\x73\x77\xf5\xe7\x4a\xac\x6a\x65\x09\x7f\x16\x87\xfa\xbf\xfc\xdc\x27\xbc\xf8\x7a\x1d\x20\xbe\x16\x6a\xee\xaa\xe0\x63\xee\x69\x36\x5d\xb4\xdf\xbb\x7b\x88\x81\x7d\xcb\xfb\x37\x76\xf1\x75\xb9\x16\x82\x02\x97\x52\x67\x39\xb4\x78\x7d\x28\x9b\x3a\xf5\x9b\xe7\x0a\xe2\xeb\x40\x13\xe0\xa6\x6f\xf0\xb6\xdf\xbf\x15\x8e\xd2\x0f\x4d\xd3\x8d\x8e\x0d\x84\xb7\x8b\xfb\x37\x76\x5c\x7e\xed\xe0\x36\x8b\x50\xfe\xec\xa0\xe8\xff\x45\xee\x13\xc2\x1b\x00\xe2\xeb\x41\x3d\xc0\xb2\x33\x6e\x1d\x2b\xb8\x08\x34\xdc\xd7\x88\xf4\xfa\x84\xc5\xf7\x30\x5d\x02\xae\xcf\x77\x8e\xde\x44\x4a\xfa\xe1\xde\x11\xe8\x31\x51\x58\xbb\xbf\x9a\xe6\x89\x6a\xf7\xef\x57\x4d\x71\x39\xc9\x1e\x7c\x43\x60\xba\xae\x90\xb1\x66\xdb\x25\xa5\x76\xd0\x58\xee\xcf\x83\xdc\x9f\xba\x22\x7c\x91\xef\x3d\x90\xd9\x10\xce\x8f\xcf\x4f\xef\x2e\xdb\xa0\x21\x81\xb8\x22\x2f\x75\x21\x53\xd3\x8b\x26\x7e\xe7\xaa\xaf\x4b\x72\x7f\x4d\x81\x0d\x1d\x15\xd4\xf8\x39\xb5\xbe\x0e\xd9\xa6\x5d\x04\xb4\xf4\x50\x4a\x9f\x14\x79\xb5\x77\x72\x9c\x45\x38\x4e\xd2\x1f\x9d\xfb\xdc\x2d\xf7\x2f\xa9\xfc\xed\xe3\x54\x02\x45\x92\xd5\xf0\x22\x3e\xde\x85\xbc\x40\xf7\x6d\xfb\x4e\xcb\xbd\x2e\xee\x91\xee\xc6\xb8\x16\x63\x5d\xcf\x71\x87\x7a\x20\xbe\x03\x90\x66\xf9\x8b\xe4\x03\xbb\x38\x8a\x85\x36\xb5\xb6\x35\x12\x5f\x80\xb9\x83\xdb\x61\x18\x42\x52\xd6\xc8\xac\x00\x98\x11\x88\x6f\xcf\xa4\x59\xfe\x14\x98\x2f\x4a\x3e\x24\xc0\x8c\x60\x91\x85\x03\xf1\x0f\xbe\x6b\x89\xe6\xb5\x02\x52\x22\xbc\x41\x55\xcd\xc8\x89\x04\x98\x17\x88\xaf\x9b\x22\x88\xa1\xd7\x22\x38\xc9\x71\x91\xe0\x5a\xc9\x62\xd5\x8a\xb3\xf8\x56\xff\xe8\x90\x9a\x03\x30\x33\x10\x5f\x37\x26\xf1\x5c\xe9\x3f\xef\xa8\xa0\x0e\x56\x2f\xc0\xcc\xc0\xe7\x6b\x41\x52\x78\x86\x58\xe1\x44\xaa\x0e\xc0\x0c\x41\x7c\xed\x0c\xb1\xcd\xcc\xb5\x87\xa5\x9d\x00\x30\x01\x10\x5f\x3b\x43\x58\xbd\xcf\x54\x7d\x02\x98\x27\x88\xaf\x9d\xbe\xc5\x97\xe2\x23\x00\x33\x06\xf1\xb5\xd3\x64\x8d\x7b\x08\x17\x59\x03\x7f\x2b\xc2\xdb\x45\xcd\x09\x80\xd9\xc1\xf2\x62\x0f\x5a\x51\xf5\x55\x4b\x6b\xf8\x22\x6b\xee\xb1\x76\x01\x00\xf1\xad\x83\x96\x01\xa1\x17\x83\xb1\x65\x45\x9c\xb4\x02\x24\xbd\x14\x89\x01\x80\xe9\x82\xf8\x02\x00\x44\x00\x9f\x2f\x00\x40\x04\x10\x5f\x00\x80\x08\x20\xbe\x00\x00\x11\x40\x7c\x01\x00\x22\x80\xf8\x02\x00\x44\x00\xf1\x05\x00\x88\x00\xe2\x0b\x00\x10\x01\xc4\x17\x00\x20\x02\x88\x2f\x00\x40\x04\x10\x5f\x00\x80\x08\x20\xbe\x00\x00\x11\x40\x7c\x01\x00\x22\x80\xf8\x02\x00\x44\x00\xf1\x05\x00\x88\x00\xe2\x0b\x00\x10\x01\xc4\x17\x00\x20\x02\x88\x2f\x00\x40\x04\x10\x5f\x00\x80\xa1\x49\x92\xe4\x1f\x15\x1f\xe6\x11\x6a\x11\x32\xd4\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82";
//#endregion

// Parameters
var GENERATE_REPORT = false;
var CLEAN_CONFIG_AT_START = true;
var ADD_SUFFIX_TO_OPTIMIZED_GIF = false;
var BUTTON_HEIGHT = 50;
var BUTTON_WIDTH = 100;
var LAST_UPDATED = (function (dateString) {
    var parts = dateString.split(".");
    if (parts.length === 3) {
        var day = parts[2].length === 1 ? "0" + parts[2] : parts[2];
        var month = parts[1].length === 1 ? "0" + parts[1] : parts[1];
        var year = parts[0].length === 2 ? parts[0] : parts[0].slice(-2);

        return "1." + year + "." + month + "." + day;
    }
    else {
        return dateString;
    }
})("24.06.24");

// Global Variables
var SCRIPT_NAME = "gifpt";
var USER_NAME = $.getenv("USERNAME");
var script_path = File($.fileName).path;
var dithering_methods = ["ordered", "floyd-steinberg", "ro64", "o3", "o4", "o8", "halftone"];

var successMessage = "";
var global_progress_window;
var configFilePath = getConfigPath();
var palettePath, videoInput, outputDirectory;
var config, configDefinitions;
var accepted_formats = /\.(mp4|mov|avi)$/i;

/**
 * Returns a randomized exclamation.
 */
function errorText() {
    var exclamations = [
        "Uh-oh...",
        "Oops!",
        "Yikes!",
        "Hmm...",
        "Whoops!",
        "Ah!",
        "Oh dear...",
        "Drat!",
        "Oopsie!",
        "Ugh...",
        "Oh geez...",
        "Hey, so...",
        "Oh no...",
        "Error",
        "Error...!?",
        "Please don't be mad at me...",
        "Hey, " + USER_NAME + "...",
        "Now " + USER_NAME + "..."
    ];
    var randomIndex = Math.floor(Math.random() * exclamations.length);
    return exclamations[randomIndex];
}

/**
 * Returns a randomized exclamation.
 */
function successText() {
    var confirmations = [
        "Success!",
        "Done.",
        "All clear.",
        "Finished.",
        "No issues.",
        "All set.",
        "Processed.",
        "Confirmed.",
        "We did it!",
        "We did it, " + USER_NAME + "!"
    ];
    var randomIndex = Math.floor(Math.random() * confirmations.length);
    return confirmations[randomIndex];
}

/**
 * Returns a randomized processing phrase.
 */
function processingPhrase() {
    var phrases = [
        "Munching",
        "Converting",
        "Processing",
        "Thinking about",
        "Pondering",
        "Visualizing",
        "Transforming",
        "Evaluating",
        "Reviewing",
        "Interpreting",
        "Assessing",
        "Breaking down",
        "Sifting through",
        "Tackling",
        "Digesting",
        "Scrutinizing",
        "Filtering",
        "Parsing",
        "Handling",
        "Understanding",
        "Deciphering",
        "Mastering",
        "Refining",
        "Polishing",
        "Composing",
        "Designing",
        "Developing",
        "Orchestrating",
        "Enhancing",
        "Perfecting",
        "Doing my best on",
        "(Not Responding) on",
        "(Not Responding) over",
        "(Not Responding) about",
        USER_NAME + "'s favorite:",
        USER_NAME + "'s least favorite:",
        "Taking my time with",

    ];
    var randomIndex = Math.floor(Math.random() * phrases.length);
    return phrases[randomIndex];
}

/**
 * Generates a timestamp formatted as a string.
 * @param {number} length - The complexity of the output string.
 * @returns {string} - The formatted timestamp.
 */
function getFormattedTimestamp(length) {
    var now = new Date();
    var units = [
        now.getFullYear(),
        ('0' + (now.getMonth() + 1)).slice(-2),
        ('0' + now.getDate()).slice(-2),
        ('0' + now.getHours()).slice(-2),
        ('0' + now.getMinutes()).slice(-2),
        ('0' + now.getSeconds()).slice(-2)
    ];

    if (typeof length === 'undefined' || isNaN(length) || length < 1 || length > units.length) {
        length = units.length;
    } else {
        length = Math.floor(length);
    }

    return units.slice(units.length - length).join('-');
}

/**
 * Cleans a given string by removing leading and trailing whitespaces.
 * @param {string} str - The string to be cleaned.
 * @returns {string} - The cleaned string.
 */
function cleanSpaces(str) {
    if (str) {
        // Regex to remove leading and trailing whitespace
        var cleanedStr = str.replace(/^\s+|\s+$/g, '');
        return cleanedStr
    }
    return "";
}

/**
 * Replaces the file extension of a given file path with a new extension.
 * @param {File} filePath - The file whose extension is to be replaced.
 * @param {string} newExtension - The new file extension to apply.
 * @returns {string} - The file name with the new extension.
 */
function replaceFileExtension(filePath, newExtension) {
    var fileName = filePath.name;
    var dotIndex = fileName.lastIndexOf('.');
    if (dotIndex > -1) {
        fileName = fileName.substring(0, dotIndex);
    }
    return fileName + newExtension;
}

/**
 * Replaces the file extension of a given file path with a new extension.
 * @param {File} filePath - The file whose extension is to be replaced.
 * @param {string} newExtension - The new file extension to apply.
 * @returns {string} - The file name with the new extension.
 */
function replaceFileExtension(filePath, newExtension) {
    var fileName = filePath.name;
    var dotIndex = fileName.lastIndexOf('.');
    if (dotIndex > -1) {
        fileName = fileName.substring(0, dotIndex);
    }
    return fileName + newExtension;
}

/**
 * Extracts the filename from a full path, removing the extension.
 * @param {String} filePath - The full path to the file.
 * @return {String} The filename without the extension, or the original path if extraction fails.
 */
function extractFileName(filePath) {
    try {
        // Extract the last segment after the last slash
        var fileNameWithExtension = filePath.match(/[^\\\/]+$/)[0];
        // Remove the extension from the file name
        var fileName = fileNameWithExtension.replace(/\.[^\.]+$/, '');
        return fileName;
    } catch (e) {
        // Return the original path if any error occurs
        return filePath;
    }
}

//#region User Interface

/**
 * Creates a base prompt window with common properties.
 * @param {string} title - The title of the dialog window.
 * @param {string} message - The message to be displayed.
 * @returns {Window} - The created window object.
 */
function createBasePromptWindow(title, message) {
    var win = new Window("dialog", title, undefined, { resizeable: true });
    win.orientation = "column";
    win.alignChildren = ["fill", "fill"];
    win.spacing = 10;
    win.margins = 25;
    win.preferredSize = [300, 20];

    win.onResize = function () {
        this.layout.resize();
    };

    var messageText = win.add("statictext", undefined, message, { multiline: true });

    return win;
}

/**
 * Displays a custom dialog window for input or selections.
 * @param {string} title - The title of the dialog window.
 * @param {string} message - The message to be displayed.
 * @param {string[]} choices - An array of string choices for buttons (null if text input is needed).
 * @param {string} defaultValue - Default text value if applicable.
 * @param {string} actionButtonText - The text for the window's action button.
 * @returns {string|null} - The value entered or chosen by the user, or null if cancelled.
 */
function createPromptWindow(title, message, choices, defaultValue, actionButtonText, valueType) {

    // Create a base window for building the prompt
    var win = createBasePromptWindow(title, message);

    // Create a variable to store the user's input
    var input = null;

    // TODO Replace if block with case statements based on value type
    if (choices) {
        var buttonGroup = win.add("group");
        buttonGroup.orientation = "row";
        buttonGroup.alignChildren = ["fill", "center"];
        for (var i = 0; i < choices.length; i++) {
            var choice = choices[i];
            var btn = buttonGroup.add("button", undefined, choice);
            btn.preferredSize = [BUTTON_WIDTH, BUTTON_HEIGHT];
            btn.onClick = function () {
                input = this.text;
                win.close();
            };
        }
    }
    else {
        var inputGroup = win.add("group");
        inputGroup.orientation = "row";
        inputGroup.alignChildren = ["fill", "center"];
        var inputField = inputGroup.add("edittext", undefined, defaultValue);
        inputField.characters = 50;

        var okButton = win.add("button", undefined, "OK");
        okButton.preferredSize = [BUTTON_WIDTH, BUTTON_HEIGHT];
        okButton.onClick = function () {
            input = inputField.text;
            win.close();
        };
    }

    var actionGroup = win.add("group");
    actionGroup.orientation = "row";
    actionGroup.alignChildren = ["fill", "center"];

    var cancelButton = actionGroup.add("button", undefined, actionButtonText ? actionButtonText : "Cancel");
    cancelButton.preferredSize = [BUTTON_WIDTH, BUTTON_HEIGHT];
    cancelButton.onClick = function () {
        win.close();
    };

    win.center();
    win.show();
    return input;
}

/**
 * Displays a custom dialog window for displaying a logo.
 * @param {string} title - The title of the dialog window.
 * @param {string} message - The message to be displayed.
 * @param {string} logo - The binary for the logo to be displayed
 * @returns {string|null} - The value entered or chosen by the user, or null if cancelled.
 */
function createLogoWindow(title, message, choices, continueButtonText, logoBin) {
    var win = new Window("dialog", title, undefined, { resizeable: true });
    win.orientation = "column";
    win.alignChildren = ["fill", "fill"];
    win.spacing = 10;
    win.margins = 25;
    win.preferredSize = [300, 20];

    win.onResize = function () {
        this.layout.resize();
    };

    var logoGroup = win.add("group");
    logoGroup.alignChildren = ["fill", "center"];
    var logo = logoGroup.add("image", undefined, logoBin);

    var messageText = win.add("statictext", undefined, message, { multiline: true });

    var actionGroup = win.add("group");
    actionGroup.orientation = "row";
    actionGroup.alignChildren = ["fill", "center"];

    var continueButton = actionGroup.add("button", undefined, continueButtonText ? continueButtonText : "Continue");
    continueButton.preferredSize = [BUTTON_WIDTH, BUTTON_HEIGHT];
    continueButton.onClick = function () {
        win.close();
    };

    win.center();
    win.show();
    return null;
}

/**
 * Creates a progress bar window.
 * @param {string} title - The title of the progress bar window.
 * @param {number} maxValue - The maximum value of the progress bar.
 * @returns {Object} An object containing the progress bar and the window.
 */
function createProgressBar(title, maxValue) {

    var progress_bar_window = new Window("palette", title, undefined, { closeButton: false, independent: true });
    var progress_bar = progress_bar_window.add("progressbar", undefined, 0, maxValue);

    progress_bar.preferredSize = [300, 20];

    progress_bar_window.redraw = function () {
        progress_bar_window.update();
    }

    progress_bar_window.updateTitle = function (newTitle) {
        progress_bar_window.text = newTitle;
        progress_bar_window.update();
    };

    progress_bar_window.updateProgress = function (value) {
        progress_bar.value = value;
        progress_bar_window.update();
    };

    progress_bar_window.seppuku = function () {
        progress_bar_window.hide();
        progress_bar_window.close();
        progress_bar_window.visible = false;
    }

    return {
        progress_bar: progress_bar,
        window: progress_bar_window
    };
}

/**
 * Logs a message to a log file, with a timestamp, the name of the associated file, and appends the config content.
 * @param {string} message - The message to log.
 * @param {string} logFileName - A string to label the log with.
 * @param {object} config - The configuration settings to append.
 * @param {string} outputDirectory - The directory where the output GIFs are saved.
 */
function logMessage(message, logFileName, config, outputDirectory) {

    var logMessageContent = "";
    var timestamp = getFormattedTimestamp(5);

    var formattedConfigSettings = JSON.stringify(
        config,
        null,  // No replacer function - include all properties
        4      // Number of spaces for indentation
    );

    var outputFileName = extractFileName(logFileName);
    var logFolderPath = outputDirectory + "/log";
    var logFilePath = logFolderPath + "/" + outputFileName + "_" + timestamp + ".txt";
    var logFolder = new Folder(logFolderPath);

    // Create the log folder if it doesn't already exist
    if (!logFolder.exists) {
        if (!logFolder.create()) {
            createPromptWindow(errorText(), "Failed to create log folder: " + logFolderPath + "\n", ["Try again..."], null);
            return;
        }
    }

    var logFile = new File(logFilePath);

    if (logFile.open('w')) {
        logMessageContent += "Config Path: " + decodeURIComponent(configFilePath) + "\n\n";
        logMessageContent += "Config Settings:" + "\n" + formattedConfigSettings + "\n\n";
        logMessageContent += "Logged Messages:" + "\n";
        logMessageContent += message;

        logFile.writeln(logMessageContent);

        logFile.close();
    }
    else {
        createPromptWindow(errorText(), "Failed to open log file for writing: " + logFilePath + "\n", ["Try again..."], null);
    }
}

/**
 * Prompts the user for a value for a given configuration key, using a custom dialog window.
 * @param {string} key - The configuration key.
 * @param {string} valueType - The type of value (path, boolean, text).
 * @param {string} inputType - The type of input method (system_dialog, boolean, text_input, text_input_pair, radio).
 * @param {string} defaultValue - The default value for the configuration key.
 * @param {string} description - Description of what the configuration key affects.
 * @returns {string|null} - The user-provided value or null if none.
 */
function promptForValue(key, valueType, inputType, defaultValue, description) {

    var defaultValueLabel = defaultValue === "" ? "Default: Blank" : "Default: " + defaultValue;

    var promptMessage = description + "\n\n" + "Please enter the value for " + key + " (" + defaultValueLabel + "):"

    switch (valueType) {
        case 'path':
            var initialPath = defaultValue && new File(defaultValue).exists ? new File(defaultValue) : undefined;
            var fileObj = File.openDialog("Please locate: " + key, undefined, initialPath);
            return fileObj ? fileObj.fsName : (defaultValue || null);
        case 'boolean':
            var choices = ["Yes", "No"];
            var result = createPromptWindow("Setup: " + key, promptMessage, choices);
            return result === "Yes" ? "true" : "false";
        default:
            return createPromptWindow("Setup: " + key, promptMessage, null, defaultValue);
    }
}

/**
 * Prompts the user to select a video input source.
 * @returns {Array|string|null} - The selected video files or null if none.
 */
function promptForVideoInput() {

    var this_setting_name = SCRIPT_NAME + LAST_UPDATED;

    var choices = ["Select File(s)", "Select Folder"];
    var userChoice = createPromptWindow("Setup: videoInput", "Select individual files, or a folder?", choices, null);

    if (userChoice === "Select File(s)") {
        var lastFileDirectory = (app.settings.haveSetting(this_setting_name, "last_selected_file_folder"))
            ? app.settings.getSetting(this_setting_name, "last_selected_file_folder") : null;

        var videoInput = File.openDialog("Select video file(s) for conversion.", undefined, true, lastFileDirectory ? new Folder(lastFileDirectory) : undefined);
        if (videoInput) {
            if (videoInput instanceof File) {
                app.settings.saveSetting(this_setting_name, "last_selected_file_folder", videoInput.parent.fsName);
                return [videoInput.fsName];
            }
            else if (videoInput instanceof Array) {
                app.settings.saveSetting(this_setting_name, "last_selected_file_folder", videoInput[0].parent.fsName);
                return videoInput.filter(function (file) {
                    return file instanceof File && file.name.match(accepted_formats);
                }).map(function (file) { return file.fsName; });
            }
        }
    }
    else if (userChoice === "Select Folder") {
        var lastDirDirectory = (app.settings.haveSetting(this_setting_name, "last_selected_dir_folder"))
            ? app.settings.getSetting(this_setting_name, "last_selected_dir_folder") : null;

        var videoInputDir = Folder.selectDialog("Select a folder containing video(s) for conversion.", lastDirDirectory ? new Folder(lastDirDirectory) : null);
        if (videoInputDir) {
            app.settings.saveSetting(this_setting_name, "last_selected_dir_folder", videoInputDir.fsName);
            return videoInputDir.getFiles(function (file) {
                return file instanceof File && file.name.match(accepted_formats);
            }).map(function (file) { return file.fsName; });
        }
    }

    return null;
}

/**
 * Prompts the user to select a directory to save the output GIFs.
 * @returns {string|null} - The selected directory or null if none.
 */
function promptForOutputDirectory() {

    var this_setting_name = SCRIPT_NAME + LAST_UPDATED;

    var lastOutputDirectory = (app.settings.haveSetting(this_setting_name, "last_selected_output_folder"))
        ? app.settings.getSetting(this_setting_name, "last_selected_output_folder") : null;

    var outputDirectory = Folder.selectDialog("Select a directory to save the output GIFs.", lastOutputDirectory ? new Folder(lastOutputDirectory) : null);
    if (outputDirectory) {
        app.settings.saveSetting(this_setting_name, "last_selected_output_folder", outputDirectory.fsName);
        return outputDirectory.fsName;
    }
    else {
        return null;
    }
}

//#endregion

//#region Command Assembly

/**
 * Optimizes the output GIFs using Gifsicle.
 * @param {string} gifsiclePath - The path to the Gifsicle executable.
 * @param {string} outputDirectory - The directory where the output GIFs are saved.
 * @param {Array} inputFiles - The original video files that were converted to GIFs.
 * @param {object} config - User-configured settings.
 */
function optimizeGIFs(gifsiclePath, outputDirectory, inputFiles, config) {
    var userSelection = createPromptWindow("Setup: Optimization", "Attempt to optimize GIFs?\n", ["Yes", "No"], null);

    var loggedGifsicleCommands = "";

    if (userSelection !== "Yes") {
        return;
    }

    var progressWindowTitle = "Optimizing GIFS...";
    global_progress_window = createProgressBar(progressWindowTitle, inputFiles.length);
    global_progress_window.window.show();

    var optimizedGIFSuffix = ADD_SUFFIX_TO_OPTIMIZED_GIF ? "-optimized" : "";

    for (var i = 0; i < inputFiles.length; i++) {

        var newTitle = " Optimizing GIFs...";
        global_progress_window.window.updateTitle(newTitle);

        var inputFile = inputFiles[i];
        var outputFileName = decodeURIComponent(replaceFileExtension(new File(inputFile), optimizedGIFSuffix + ".gif"));
        var inputFilePath = "\"" + outputDirectory + "/" + decodeURIComponent(replaceFileExtension(new File(inputFile), ".gif")) + "\"";
        var outputFilePath = "\"" + outputDirectory + "/" + outputFileName + "\"";

        var gifsicleCommand = gifsiclePath + " -O3 " + inputFilePath + " --lossy=" + config.lossyLevel + " --dither=" + config.ditheringMethod + " -o " + outputFilePath;

        global_progress_window.window.redraw();

        var result = system.callSystem(gifsicleCommand);

        global_progress_window.window.updateProgress(i + 1);

        loggedGifsicleCommands += "\n" + gifsicleCommand + "\n";
    }

    global_progress_window.window.seppuku();

    if (GENERATE_REPORT) {
        logMessage(loggedGifsicleCommands, "_" + SCRIPT_NAME + "-optimize-log", config, outputDirectory);
    }
}

/**
 * Builds FFMPEG command lines for converting videos to GIFs based on user config.
 * @param {string} ffmpegPath - The path to the FFMPEG executable.
 * @param {Array} inputFiles - The input video files.
 * @param {string} outputDirectory - The directory where the output GIFs should be saved.
 * @param {object} config - User-configured settings.
 * @returns {Array} - The FFMPEG commands.
 */
function buildFFMPEGCommand(ffmpegPath, inputFiles, outputDirectory, config) {
    var commands = [];

    for (var i = 0; i < inputFiles.length; i++) {

        var inputFile = inputFiles[i];

        var outputFileName = decodeURIComponent(replaceFileExtension(new File(inputFile), ".gif"));

        var outputFilePath = outputDirectory + "/" + outputFileName;

        var startTime = config.startTime ? "-ss " + config.startTime : "";

        var duration = config.duration ? "-t " + config.duration : "";

        var playbackSpeed = config.playbackSpeed ? "setpts=" + (1 / parseFloat(config.playbackSpeed)) + "*PTS" : "";

        var numColors = config.numColors ? (config.numColors > 256 ? 256 : config.numColors) : "256";

        inputFile = "\"" + inputFile + "\"";
        palettePath = "\"" + outputDirectory + "\\palette.png\"";
        outputFilePath = "\"" + outputFilePath + "\"";

        if (config.gifPaletteGen === 'true') {
            var paletteGenCmd = ffmpegPath + " -y " + startTime + " -i " + inputFile +
                " -vf \"fps=" + config.gifFps + ",scale=" + config.gifScale +
                ",palettegen=max_colors=" + numColors + "\" " +
                "-frames:v 1 -update 1 " + palettePath;
            var paletteUseCmd = ffmpegPath + " -y " + startTime + " -i " + inputFile + " -i " + palettePath +
                " -filter_complex \"[0:v]" + playbackSpeed + ",fps=" + config.gifFps +
                ",scale=" + config.gifScale + "[x];[x][1:v]paletteuse\" " +
                "-loop " + config.gifLoopCount + " " + outputFilePath + " " + duration;

            commands.push(paletteGenCmd);
            commands.push(paletteUseCmd);
        }
        else {
            var filter = "fps=" + config.gifFps + ",scale=" + config.gifScale +
                ",split[x][z];[z]palettegen=max_colors=" + numColors + "[p];[x][p]paletteuse";
            var command = ffmpegPath + " -y " + startTime + " -i " + inputFile +
                " -filter_complex \"" + playbackSpeed + "," + filter + "\" " +
                "-loop " + config.gifLoopCount + " " + outputFilePath + " " + duration;
            commands.push(command);
        }
    }

    return commands;
}

/**
 * Executes the provided FFMPEG commands.
 * @param {Array} commands - The FFMPEG commands to execute.
 * @param {Array} inputFiles - The original video files to be converted.
 * @param {Array} config - The conversion settings, defined by the user.
 */
function executeFFMPEGCommand(commands, inputFiles, config) {
    var loggedFFMPEGCommands = "";

    var progressWindowTitle = "Processing GIFS...";
    global_progress_window = createProgressBar(progressWindowTitle, commands.length);
    global_progress_window.window.show();

    var calculatedCurrentGIF = 1;

    // Execute each command.
    for (var i = 0; i < commands.length; i++) {

        global_progress_window.window.redraw();
        var newTitle = processingPhrase() + " GIF " + (calculatedCurrentGIF) + " of " + videoInput.length;
        global_progress_window.window.updateTitle(newTitle);

        var command = commands[i];
        var result = system.callSystem(command);

        // When palette generation is enabled, there are two commands per GIF (palette generation and conversion),
        // so the commands array is twice the size of the input array. We adjust calculatedCurrentGIF accordingly:
        // We determine the next GIF number by comparing (calculatedCurrentGIF + 1) to videoInput.length
        // If (calculatedCurrentGIF + 1) would exceed the total number of input files, we cap it at the total number of files
        // If (calculatedCurrentGIF + 1) is not greater than the total number of input files, we increment calculatedCurrentGIF by 1
        calculatedCurrentGIF = (calculatedCurrentGIF + 1 > videoInput.length) ? videoInput.length : calculatedCurrentGIF + 1;

        global_progress_window.window.updateProgress(i + 1);

        loggedFFMPEGCommands += "\n" + result + "\n";
    }

    global_progress_window.window.seppuku();

    // Create a log for each processed video, and for the FFMPEG results.
    if (GENERATE_REPORT) {
        logMessage(loggedFFMPEGCommands, "_" + SCRIPT_NAME + "-log", config, outputDirectory);
        for (var i = 0; i < inputFiles.length; i++) {
            logMessage(commands[i], inputFiles[i], config, outputDirectory);
        }
    }
}

//#endregion

//#region Config

/**
 * Gets the path to the configuration file in the appdata folder.
 * @returns {string} - The path to the configuration file.
 */
function getConfigPath() {
    var configFolder;
    if ($.os.indexOf("Mac") !== -1) {
        configFolder = new Folder(Folder.userData.fsName + "/Application Support/" + SCRIPT_NAME);
    } else {
        configFolder = new Folder(Folder.userData.fsName + "/" + SCRIPT_NAME);
    }

    if (!configFolder.exists) {
        configFolder.create();
    }

    return configFolder.fsName + "/config.txt";
}

/**
 * Initializes the configuration by loading existing settings or prompting the user for new ones.
 * @param {string} filePath - The path to the configuration file.
 * @param {object} configDefinitions - Definitions of config settings.
 * @returns {object|null} - The initialized configuration object or null if a required config value is missing.
 */
function initializeConfig(filePath, configDefinitions) {
    var changesMade = false;
    config = loadConfig(filePath);

    for (var key in configDefinitions) {
        // If the value for a given key is undefined, or blank (but blank values are not allowed) then we...
        if (config[key] === undefined || (config[key] === '' && !configDefinitions[key].allow_blank)) {
            // First, read information from configDefinitions for the current key.
            var valueType = configDefinitions[key].type;
            var inputType = configDefinitions[key].input_type;
            var defaultValue = configDefinitions[key].default_value || '';
            var description = configDefinitions[key].desc;

            // Prompt the user for that key's value.
            var userValue = promptForValue(key, valueType, inputType, defaultValue, description);

            // If the response is valid, store the value and flag that the config was updated.
            if (userValue !== null) {
                config[key] = userValue;
                changesMade = true;
            }
            // If the user provides an invalid value, or closes the prompt,
            // and we require a value for that key, prompt the user to retry and exit.
            else if (!configDefinitions[key].allow_blank) {
                createPromptWindow(errorText(), key + " is required to proceed." + "\n", ["OK"], null);
                return null;
            }
        }
    }

    // Save the updated config if changes were made.
    if (changesMade) {
        saveConfig(filePath, config, configDefinitions);
    }

    return config;
}

/**
 * Loads configuration settings from a given file.
 * @param {string} filePath - The path to the configuration file.
 * @returns {object} - The loaded configuration.
 */
function loadConfig(filePath) {
    var configFile = new File(filePath);
    var config = {};
    if (configFile.exists) {
        configFile.open('r');
        var content = configFile.read();
        configFile.close();
        try {
            config = JSON.parse(content);
        } catch (e) {
            // If parsing fails, return an empty object
            config = {};
        }
    }
    return config;
}

/**
 * Saves configuration settings to a file.
 * @param {string} filePath - The path to the configuration file.
 * @param {object} config - The configuration settings to save.
 * @param {object} configDefinitions - Definitions of config settings including write_to_config field.
 */
function saveConfig(filePath, config, configDefinitions) {
    var configFile = new File(filePath);
    var configToSave = {};
    for (var key in config) {
        if (config.hasOwnProperty(key) && configDefinitions[key].write_to_config) {
            configToSave[key] = config[key];
        }
    }
    var jsonString = JSON.stringify(configToSave, null, 2);
    configFile.open('w');
    configFile.write(jsonString);
    configFile.close();
}
/**
 * Clears fragile values from the configuration settings if the user confirms.
 * @param {string} filePath - The path to the configuration file.
 * @param {object} config - The current configuration settings.
 * @param {object} configDefinitions - Definitions of config settings including fragile field.
 */
function cleanConfig(filePath, config, configDefinitions) {
    var userSelection = createPromptWindow("Setup: config", "Reset config settings?\n", ["Yes"], null, "No");

    if (userSelection === "Yes") {
        for (var key in configDefinitions) {
            if (configDefinitions[key].fragile) {
                delete config[key];
            }
        }
        saveConfig(filePath, config, configDefinitions);
    }
}

//#endregion

//#region Main
/**
 * Main function to handle user interactions and processing.
 */
function main() {
    var startTime = new Date().getTime();

    // Clean the config file, optionally
    if (CLEAN_CONFIG_AT_START && config && configDefinitions && configFilePath) {
        cleanConfig(configFilePath, config, configDefinitions);
    }

    // Start screen
    createLogoWindow(SCRIPT_NAME + " v" + LAST_UPDATED, "", null, "Make some gifs!", main_logo_binary,);

    // GIF Conversion Parameters
    configDefinitions = {
        'ffmpegPath': {
            type: 'path',
            input_type: 'system_dialog',
            default_value: '',
            desc: 'Locate the path to the FFMPEG executable.',
            write_to_config: true,
            allow_blank: false,
            fragile: false,
        },
        'gifsiclePath': {
            type: 'path',
            input_type: 'system_dialog',
            default_value: '',
            desc: 'Locate the path to the gifsicle executable.',
            write_to_config: true,
            allow_blank: false,
            fragile: false,
        },
        'gifScale': {
            type: 'text',
            input_type: 'text_input_pair',
            default_value: '-1:-1',
            desc: 'Resolution for the output GIF. Specify as width:height (e.g., 320:240).\n\nUse -1 for width or height to automatically adjust that dimension to maintain the aspect ratio based on the other value.\n\nSetting both to -1 will use the original video’s resolution.',
            write_to_config: true,
            allow_blank: false,
            fragile: true,
        },
        'gifFps': {
            type: 'text',
            input_type: 'text_input',
            default_value: '12',
            desc: 'Frame rate of the output GIF.',
            write_to_config: true,
            allow_blank: false,
            fragile: true,
        },
        'numColors': {
            type: 'text',
            input_type: 'text_input',
            default_value: '256',
            desc: 'Maximum number of colors for the GIF. Lower values like 128 can reduce file size but may cause color banding. Values can be set from 1 to 256.',
            write_to_config: true,
            allow_blank: false,
            fragile: true,
        },
        'gifPaletteGen': {
            type: 'boolean',
            input_type: 'boolean',
            default_value: 'true',
            desc: 'Whether to generate a custom color palette for each GIF.\nTrue enhances color quality, especially for complex videos.\n\nFalse uses a standard palette, which may reduce quality but speeds up processing.',
            write_to_config: true,
            allow_blank: false,
            fragile: true,
        },
        'gifLoopCount': {
            type: 'text',
            input_type: 'text_input',
            default_value: '0',
            desc: 'Number of loops for the GIF playback. Set to 0 for infinite.',
            write_to_config: true,
            allow_blank: false,
            fragile: true,
        },
        'playbackSpeed': {
            type: 'text',
            input_type: 'text_input',
            default_value: '1.0',
            desc: 'Playback speed multiplier. Use values over 1.0 to speed up the GIF, and under 1.0 to slow it down.',
            write_to_config: true,
            allow_blank: false,
            fragile: true,
        },
        'startTime': {
            type: 'text',
            input_type: 'text_input',
            default_value: '0',
            desc: 'Time (in seconds) from the beginning of the video to start processing.',
            write_to_config: true,
            allow_blank: false,
            fragile: true,
        },
        'duration': {
            type: 'text',
            input_type: 'text_input',
            default_value: '',
            desc: 'Duration (in seconds) of the video clip to convert into a GIF.\nLeave blank to convert the entire video.',
            write_to_config: true,
            allow_blank: true,
            fragile: true,
        },
        'lossyLevel': {
            type: 'text',
            input_type: 'text_input',
            default_value: '100',
            desc: 'Level of lossy compression for Gifsicle. Values can be set from 0 to 100.',
            write_to_config: true,
            allow_blank: false,
            fragile: true,
        },
        'ditheringMethod': {
            type: 'text',
            input_type: 'radio',
            default_value: 'ordered',
            desc: 'Dithering method for Gifsicle. Options: ordered, floyd-steinberg, ro64, o3, o4, o8, halftone',
            write_to_config: true,
            allow_blank: false,
            fragile: true,
        }
    };

    config = initializeConfig(configFilePath, configDefinitions);

    if (!config) {
        createPromptWindow(errorText(), "Script initialization failed. Please try again." + "\n", ["OK"], null);
        return;
    }

    videoInput = promptForVideoInput();
    if (!videoInput) {
        createPromptWindow(errorText(), "What am I supposed to convert then?" + "\n", ["OK"], null);
        return;
    }

    outputDirectory = promptForOutputDirectory();
    if (!outputDirectory) {
        createPromptWindow(errorText(), "No seriously, where should we save these GIFs?" + "\n", ["OK"], null);
        return;
    }

    // If only one file is selected, still make an array with it
    var inputFiles = videoInput instanceof Array ? videoInput : [videoInput];

    var commands = buildFFMPEGCommand(config.ffmpegPath, inputFiles, outputDirectory, config);
    executeFFMPEGCommand(commands, inputFiles, config);

    if (config.gifPaletteGen === 'true') {
        var paletteFile = new File(outputDirectory + "/palette.png");
        if (paletteFile.exists) {
            paletteFile.remove();
        }
    }

    // Optimize the output GIFs, optionally
    optimizeGIFs(config.gifsiclePath, outputDirectory, inputFiles, config);

    // Clean the config file, optionally
    cleanConfig(configFilePath, config, configDefinitions);

    var endTime = new Date().getTime();
    var totalDuration = (endTime - startTime) / 1000;
    var durationMinutes = Math.floor(totalDuration / 60);
    var durationSeconds = totalDuration % 60;

    successMessage = "Video conversion to GIFs completed in " + durationMinutes + " minutes and " + durationSeconds.toFixed(2) + " seconds.\n\n";
}

main();

if (successMessage) {
    createPromptWindow(successText(), successMessage, ["Thank you!"], null, "Close");
    global_progress_window.window.update();
    global_progress_window.window.seppuku();
}

//#endregion
